#!/opt/xt/xt-perl/bin/perl
# vim: ts=8 sts=4 et sw=4 sr sta
use strict;
use warnings;
use Data::Dumper;
use GD::Graph::points;


#
# 2008/02/26 18:13:51 INFO> StopTimer.pm:16 XT::Handler::Event::StopTimer::handler - /Upload/Worklist 3.9616711139679s


sub parse_line {
    my($line) = @_;
    my $values = undef;

    chomp $line;

    if ($line =~ /^(\S+)\s(\S+)\s(DEBUG|INFO|WARN|ERROR|FATAL)>\s(\S+)\s(\S+)\s-\s(.+)$/) {
        my($date,$time,$level,$module,$caller,$content) = ($1,$2,$3,$4,$5,$6);

        #,$module,$path,
        return {
            date        => $date, 
            time        => $time,
            level       => $level,
            module      => $module,
            caller      => $caller,
            content     => $content,
        };
    }

    return;
}

sub parse_input {
    my $data = undef;
    
    while (my $line = (<>)) {
        my $rec = parse_line($line);

        if (defined $rec) {
            push @{$data}, $rec;
        }
    }

    if (not defined($data)) {
        die "parse_input() didn't produce any data\n";
    }

    return $data;
}

sub bias_by_uri {
    my($data) = @_;
    my $by_uri = undef;

    if (not defined $data) {
        warn "no data passed to bias_by_uri()";
        return;
    }

    foreach my $rec (@{$data}) {
        if ($rec->{content} =~ /^(\S+)\s(\S+)s\s+$/) {
            push @{$by_uri->{$1}}, $2;
        }
    }

    return $by_uri;
}

sub retrieve_graph_data {
    my($data) = @_;
    my $rv = undef;
    my(@x, @y, @v);

    # find longest array
    my $max_arr = 0;
    foreach my $key (keys %{$data}) {
        if (scalar @{$data->{$key}} > $max_arr) {
            $max_arr = scalar @{$data->{$key}};
        }
    }

    my @header = sort keys %{$data};
    push @{$rv}, \@header;

    # loop through and pop 'em off
    for my $i (1..$max_arr) {
        my @row = ();

        foreach my $key (sort keys %{$data}) {
            my $value = pop @{$data->{$key}};

            push @row, $value;
        }
        push @{$rv}, \@row;
    }

    return $rv;
}

sub make_points_graph {
    my($data) = @_;

    my $graph = GD::Graph::points->new( 1024, 640 )
        or die "GD::Graph::points->new failed";

    $graph->set(
        x_label         => 'URI',
        y_label         => 'response (sec)',
        title           => 'XTracker Response Times',
       # y_max_value     => 10,
       x_labels_vertical => 1,

       markers          => [4], # diagonal cross
       dclrs            => [ qw(black) ],
    ) or die $graph->error;

    open(my $IMG,'>','xt_response.png') or die $!;
    binmode $IMG;
#    print $IMG $gd->png;
    print $IMG $graph->plot( retrieve_graph_data($data) )->png;
    close $IMG;

    return;
}

sub main {

    my $data = parse_input;
    
    my $by_uri = bias_by_uri( $data );

    #warn Dumper( $by_uri );
    make_points_graph( $by_uri );
}

main;
