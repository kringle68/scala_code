#!perl

use strict;
use warnings;
use Getopt::Long::Descriptive;
use Net::Stomp;
use Net::Stomp::Frame;
use Path::Class qw(dir);
use File::Temp qw(tempdir);
use File::Copy;
use JSON::XS;
use URI;

# Dumps an ActiveMQ queue to a directory

my ($opt, $usage) = describe_options(
    'amq_send_from_logs %o',
    [ 'server|s=s',        "ActiveMQ Server (required)",   { required => 1     } ],
    [ 'port|p=i',          "STOMP port (default: 61613)",  { default  => 61613 } ],
    [ 'destination|d=s',   "ActiveMQ queue to send to",    { default => '/queue/dc1/iws' } ],
    [],
    [ 'help|h|?',          "Print usage message and exit" ],
);
$usage->leader_text(
q{This program sends messages from STDIN (one per line) to the specified
destination queue (default to /queue/dc1/iws).

Example usage:

  perl -nle 'm{RX Type: \w+: (.*)} and print $1' \
    /tmp/t/Xtracker\ Interface\ 20110613.txt | \
    perl script/amq_send_from_logs -s svc01.dc1.nap

This would take the messages from an IWS log file, and re-send them.
});

print($usage->text), exit if $opt->help;

my $stomp = Net::Stomp->new({
    hostname => $opt->{'server'},
    port     => $opt->{'port'},
});

$stomp->connect();

while (my $line=<>) {
    my $json = eval { decode_json( $line ) };
    if (!$json) {
        warn "line <$line> could not be parsed, ignoring";
        next;
    }
    my $frame = {
        destination => $opts->{destination},
        type => $json->{'@type'},
        body => $line,
    };
    my $res = eval { $stomp->send( $frame ) };
    if (!$res) {
        warn "line <$line> could not be sent ($@)";
    }
}
