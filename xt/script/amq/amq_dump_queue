#!perl

use strict;
use warnings;
use Getopt::Long::Descriptive;
use Net::Stomp;
use Path::Class qw(dir file);
use File::Path qw/ make_path /;
use File::Temp qw(tempfile);

# Dumps an ActiveMQ queue to a directory

my ($opt, $usage) = describe_options(
    'amq_dump_queue %o',
    [ 'server|s=s',        "ActiveMQ Server (required)",     { required => 1     } ],
    [ 'port|p=i',          "STOMP port (default: 61613)",    { default  => 61613 } ],
    [ 'destination|d=s',   "Queue to query (required)",      { required => 1     } ],
    [ 'output|o=s',        "Output directory (required)",    { required => 1     } ],
    [ 'timeout|t=i',       "Disconnect timeout seconds (default: 2)", { default  => 2 } ],
    [ 'prefix|x=s',        "Prefix to use for output files (default: amq)", { default  => 'amq' } ],
    [ 'pad|a=i',           "Number of digits to pad the output iterator to (default: 6)", { default => 6 } ],
    [ 'restrict|r=i',      'Maximum number of messages to download. 0 for no limit (default: 0)', { default => 0 } ],
    [ 'jmstype|j=s',       'JMSType of messages to download (default is no restriction)',],
    [],
    [ 'help|h|?',          "Print usage message and exit" ],
);

print($usage->text), exit if $opt->help;

# Ensure output directory exists
make_path( $opt->{'output'} );
-d $opt->{'output'} or die("Could not create output directory ($opt->{output})\n");

my $stomp = Net::Stomp->new({
    hostname => $opt->{'server'},
    port     => $opt->{'port'},
});

$stomp->connect();
my %options = (
    destination             => $opt->{'destination'},
    'ack'                   => 'client',
    'activemq.prefetchSize' => 1,
);
if ($opt->{'jmstype'}) {
    $options{'selector'} = "JMSType = '$opt->{jmstype}'";
}

$stomp->subscribe({
    %options
});

# without sleeping here, the script regularly returned 'All messages dumped' even when there were 100s of items in the queue
# I run it with sleep(10), but I expect that sleeping for 3 should be fine. Who knows. 
sleep(3);

# We're going to look in our output directory for files matching our output
# prefix and digit combination.
my $next_number = 0;
{
    my $match = '^' . $opt->{'prefix'} . '_(\d+)_';
    my $match_re = qr/$match/o;

    my ($biggest) =
        sort { $b <=> $a }
        map { $_->basename =~ $match_re ? $1 : () }
        grep { $_->isa('Path::Class::File') }
        dir( $opt->{'output'} )->children;

    if ( $biggest ) {
        $next_number = $biggest + 1;
    }
}
my $number_format = '%0' . $opt->{'pad'} . 'd';
my $next_filename = sub {
    my $id = shift;
    $id =~ s![/:\\\0]!_!g; # Safe, not sorry
    $id = $opt->{'prefix'} . '_' . sprintf( $number_format, $next_number++ ) .
        '_' . $id;
    my $filename = file( $opt->{'output'}, $id );
    return $filename;
};

my $messages_left = $opt->{'restrict'};
my $continue = sub {
    return 1 unless $opt->{'restrict'};
    return $messages_left--;
};

# We assume messageids are sequential
my $downloaded = 0;
while ( $continue->() ) {
    my $frame = $stomp->receive_frame({  timeout => $opt->{'timeout'}  });
    last unless $frame;

    if ( $frame->as_string !~ m/^MESSAGE/ ) {
        print STDERR "Something went wrong:\n";
        print STDERR $frame->as_string . "\n";
        die;
    }

    my $filename = $next_filename->( $frame->message_id );

    bailout( $frame, $filename, "File already exists, and we won't overwrite" )
        if -e $filename;
    open( my $fh, ">:utf8", $filename ) || bailout( $frame, $filename, $! );
    print $fh $frame->as_string;
    close $fh;

    print "Wrote $filename\n";

    $stomp->ack( { frame => $frame } );

    $downloaded++;
}
$stomp->disconnect;

if ( $opt->{'restrict'} ) {
    print "$downloaded messages downloaded (restricted to $opt->{'restrict'})\n";
} else {
    print "$downloaded messages downloaded\n";
}

sub bailout {
    my ($frame, $filename, $error) = @_;

    my ($bail_fh, $bail_filename) = tempfile();

    print STDERR "RUH ROH AN ERROR!!!\n";
    print STDERR "Can't save frame to [$filename]: $!\n";

    print $bail_fh $frame->as_string;
    close $bail_fh;

    print STDERR "I've written the last frame we read to [$bail_filename]\n";

    die "Failed to write [$filename] - last frame in [$bail_filename]\n";
}
