#!perl

use strict;
use warnings;
use Getopt::Long::Descriptive;
use Net::Stomp;
use Net::Stomp::Frame;
use Path::Class qw(dir);
use File::Temp qw(tempdir);
use File::Copy;
use JSON::XS;
use URI;

# Dumps an ActiveMQ queue to a directory

my ($opt, $usage) = describe_options(
    'amq_write_queue %o',
    [ 'server|s=s',        "ActiveMQ Server (required)",   { required => 1     } ],
    [ 'port|p=i',          "STOMP port (default: 61613)",  { default  => 61613 } ],
    [ 'input|i=s',         "Input directory (required)",   { required => 1     } ],
    [ 'dlq|d',             "Force dead-letter queue mode", { default  => 0     } ],
    [ 'raw|r',             "Force raw queue mode",         { default  => 0     } ],
    [ 'prefix|x=s',        "Prefix to use for input files (default: amq)", { default  => 'amq' } ],
    [ 'queue|q=s',         "Queue to put the messages on (default: original queue from the message files)"],
    [],
    [ 'help|h|?',          "Print usage message and exit" ],
);
$usage->leader_text(
"Note: We will move files from the directory you have specified when they have
been dealt with to a temporary directory. Messages that we fail to send will
be sent to their own temporary directory.

Messages to be replayed may or may not have originated on the dead-letter
queue. If they did, we replay the original message that lead to this message
being placed on the dead-letter queue, otherwise we replay the original message.
We attempt to work out which by looking at the path of the original message.

You can override this behaviour by forcing dead-letter queue mode, where we
assume the body of each message we read contains a message, or by forcing raw
queue mode, which assumes you want to replay the original message as it appears
in the file."
);

print($usage->text), exit if $opt->help;

my $stomp = Net::Stomp->new({
    hostname => $opt->{'server'},
    port     => $opt->{'port'},
});

$stomp->connect();

# Read directory, check for and order messages
my $dir = dir( $opt->{'input'} );
my $match = '^' . $opt->{'prefix'} . '_\d+_';
my $match_re = qr/$match/o;
my @files =
    sort
    grep { $_->basename =~ $match_re }
    grep { $_->isa('Path::Class::File') }
    $dir->children;

print "Reading input directory [$dir]\n";
print "Found " . @files . " files\n";

# Create our 'processed' directory
my $processed_dir = tempdir( CLEANUP => 0 );
print "Processed files will be placed in [$processed_dir]\n";
# Create our 'error' directory
my $failed_dir = tempdir( CLEANUP => 0 );
print "Failed files will be placed in [$failed_dir]\n";

# For each file
for my $file (@files) {

    # Parse it
    my $frame = eval { Net::Stomp::Frame->parse( scalar $file->slurp ) };
    bailout( $file, $@ ), next unless $frame;

    # Create a new frame. Although what we're ACTUALLY going to create here
    # is the arguments you'd provide to Net::Stomp->send() so you'll get back
    # an unblessed hashref
    my $new_frame;
    if ( $opt->{'dlq'} ) {
        $new_frame = new_frame_from_dlq( $file, $frame, $opt ) || next;
    } elsif ( $opt->{'raw'} ) {
        $new_frame = new_frame_from_raw( $file, $frame, $opt ) || next;
    } else {
        if ( my $parsed_body = eval { decode_json( $frame->body ) } ) {
            if ( eval { $parsed_body->{'message'}->{'original_message'} } ) {
                $new_frame = new_frame_from_dlq( $file, $frame, $opt ) || next;
            } else {
                $new_frame = new_frame_from_raw( $file, $frame, $opt ) || next;
            }
        } else {
            warn $@;
            $new_frame = new_frame_from_raw( $file, $frame, $opt ) || next;
        }
    }

    # Still here? Must have been ok
    # Fix the destination, if needed
    if ( $new_frame->{'destination'} =~ m!://! ) {
        my $d = URI->new( $new_frame->{'destination'} )->path;
        $new_frame->{'destination'} = $d;
    }
    $new_frame->{'destination'} =~ s!^!/! unless $new_frame->{'destination'} =~ m!^/!;
    $new_frame->{'destination'} =~ s!^!/queue! unless $new_frame->{'destination'} =~ m!^/queue!;

    # Send it
    bailout( $file, "Can't send msg: $@" )
        unless eval { $stomp->send( $new_frame ) };

    # Stash it
    print "Sent [$file] to $new_frame->{'destination'}\n";
    move( $file, $processed_dir );
}

sub new_frame_from_raw {
    my ($file, $frame, $opt) = @_;

    my $destination = $opt->{'queue'} || $frame->destination;
    return bailout( $file, "Couldn't find a destination" ) unless $destination;

    my $payload = $frame->body;
    my $parsed_body = eval { decode_json( $payload ) };
    my $type = $parsed_body ? $parsed_body->{'@type'} : $frame->headers->{type};

    return {
        %{$frame->headers},
        destination => $destination,
        type        => $type,
        body        => $payload
    }
}

sub new_frame_from_dlq {
    my ($file, $frame) = @_;

    my $parsed_body = eval { decode_json( $frame->body ) } ||
        return bailout( $file, "Can't parse message body as JSON: $@" );

    my $destination = $opt->{'queue'} || eval { $parsed_body->{'message'}->{'destination'} };
    return bailout( $file, "No destination found" ) unless ($destination);

    my $payload = eval { $parsed_body->{'message'}->{'original_message'} } ||
        return bailout( $file, "No payload found" );

    my $parsed_payload = eval { decode_json( $payload ) };

    return {
        destination => $destination,
        ($parsed_payload ? (type => $parsed_payload->{'@type'}) : () ),
        body        => $payload
    }
}

sub bailout {
    my $file = shift;
    my $reason = shift;
    if ( -e $file ) {
        print STDERR "Moving [$file] to the failed files directory: $reason\n";
        move( $file, $failed_dir );
    } else {
        print STDERR "File [$file] no longer exists\n";
    }
    0;
}

# THIS IS A NASTY-ASS HACK TO GET AROUND Net::Stomp::Frame's lack of a parse
# method.
package Net::Stomp::Frame;

use Net::Stomp;
# We steal Net::Stomp's parsing routines here. We'll pass the user-supplied data
# in to a throwaway object's frame buffer, and then use the reading functions.
sub parse {
    my ( $class, $data ) = @_;

    # Empty data makes no sense
    die "No data provided" unless $data;

    # Create our throwaway object
    my $ns_obj = bless {}, 'Net::Stomp';

    # Copy in to the framebuffer that the read methods rely on
    $ns_obj->{_framebuf} = $data;

    # Read headers
    die "Reading headers returned false - malformed frame?"
        unless $ns_obj->_read_headers;

    # Read body
    my $frame = $ns_obj->_read_body;
    die "Reading body returned false - malformed frame?"
        unless $frame;

    # Rebless in to the asked-for class
    bless $frame, $class;

    return $frame;
}

1;
