#!/opt/xt/xt-perl/bin/perl

# For developer machines and for DAVE environments, it's useful to have a
# reporting interface to lp. This script exists as:
#
# * script/lp_noprint
# * script/lp_print   <-- symbolic link to the former
#
# And when invoked, writes a JSON artifact describing how XT intended to call
# lp. In the latter case, it then calls out to lp, as well.

use NAP::policy "tt";

use FindBin::libs;
use FindBin::libs qw( base=lib_dynamic );
use XTracker::Config::Local;

use JSON;
use File::Basename;
use File::Which;
use Clone;

use vars qw( $option_mapping ); # We need to self-refer in o()...
local $| = 1;

my $really_print = 0;
$really_print = 1 if $0 =~ m/lp_print/;

my $options = Clone::clone( \@ARGV );
exit if ( ! scalar( @{ $options } ) );

# This is where we work out what to do with each command line option
$option_mapping = {
    # Printer name
    d => 'printer',

    # Copies
    n => 'copies',

    # Other arbitrary options. These often look like key=value, but they can
    # also just be bare. We default bare options to true. We recurse the key
    # lookup back in to this mapping hash.
    o => sub {
        my ( $hash, $option ) = @_;
        my ( $key, $value ) = split(/=/, $option);

        if ( exists( $option_mapping->{ $key } ) ) {
            $hash->{ $option_mapping->{ $key } } = $value // JSON::true();#/
        }
    },

    # Orientation (via `o`)
    'orientation-requested' => 'orientation',
    'nobanner'              => 'nobanner',
};

# This is where we build up the JSON file
my $print_options = {};

# Go through the options bit by bit
while ( @{ $options } ) {
    my $next = shift( @{ $options } );

    # If it's an option parameter, it'll start with a -
    if (! index( $next, '-' ) ) {
        # The next argument will describe that
        my $key   = substr( $next, 1 );
        my $value = shift( @{ $options } ) || '';

        # Lookup what to do with it
        my $handler = $option_mapping->{ $key } || next;

        # If it's a code-ref, then we execute that
        if ( ref $handler ) {
            $handler->( $print_options, $value );

        # Otherwise we do a straight mapping to that value
        } else {
            $print_options->{ $handler } = $value;
        }

    # Only naked argument is the filename
    } else {
        $print_options->{filename} = File::Spec->catfile( dirname( $next ), basename( $next ) );
    }
}

die 'No filename defined' if( !defined( $print_options->{filename} ) );

# Hudson is playing weird umask games. So let's hardcore this.
my $target_dir = File::Spec->catdir( dirname( $print_options->{filename} ), 'printjobs' );
mkdir( $target_dir, 0775 ) unless -d $target_dir;

my $target = File::Spec->catfile( $target_dir, ( fileparse( basename( $print_options->{filename} ), qr{\.[^\.]*$} ) )[0] );
open( my $fh, '>', $target ) || die "Can't write the printjob to [$target]: $!";
print $fh JSON::encode_json(
    {
        file_name   => basename( $print_options->{filename} ),
        file_match  => ( fileparse( basename( $print_options->{filename} ), qr{\.[^\.]*$} ) )[0],
        file_path   => dirname( $print_options->{filename} ),
        orientation => $print_options->{orientation},
        printer     => $print_options->{printer},
        copies      => $print_options->{copies},
        via         => $0
    }
);
close( $fh );

if ( $really_print ) {
    # Call LP, propogating the exit value
    exit system( sprintf( '%s %s', File::Which::which('lp'), join( ' ', @ARGV ) ) );
} else {
    # This is dummy output
    print "request id1\n";
}
