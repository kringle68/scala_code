#!/opt/xt/xt-perl/bin/perl
# vim: ts=8 sts=4 et sw=4 sr sta
use strict;
use warnings;
use Data::Dumper;
use Data::Dump qw(pp);
use GD::Graph::mixed;
#use GD::Graph::colour qw( :colours );


#
# 2008/02/26 18:13:51 INFO> StopTimer.pm:16 XT::Handler::Event::StopTimer::handler - /Upload/Worklist 3.9616711139679s


sub parse_line {
    my($line) = @_;
    my $values = undef;

    chomp $line;

    if ($line =~ /^(\S+)\s(\S+)\s(DEBUG|INFO|WARN|ERROR|FATAL)>\s(\S+)\s(\S+)\s-\s(.+)$/) {
        my($date,$time,$level,$module,$caller,$content) = ($1,$2,$3,$4,$5,$6);

        #,$module,$path,
        return {
            date        => $date, 
            time        => $time,
            level       => $level,
            module      => $module,
            caller      => $caller,
            content     => $content,
        };
    }

    return;
}

sub parse_input {
    my $data = undef;
    
    while (my $line = (<>)) {
        my $rec = parse_line($line);

        if (defined $rec) {
            push @{$data}, $rec;
        }
    }

    return $data;
}

sub bias_by_uri {
    my($data) = @_;
    my $by_uri = undef;

    return undef if (not defined $data);

    foreach my $rec (@{$data}) {
        if ($rec->{content} =~ /^(\S+)\s(\S+)s$/) {
            push @{$by_uri->{$1}}, $2;
        }
    }

    return $by_uri;
}

sub retrieve_graph_data {
    my($data) = @_;
    my $rv = undef;
    my(@x, @y, @v);

    # find longest array
    my $max_arr = 0;
    foreach my $key (keys %{$data}) {
        if (scalar @{$data->{$key}} > $max_arr) {
            $max_arr = scalar @{$data->{$key}};
        }
    }

    my @header = sort keys %{$data};
    push @{$rv}, \@header;

    # loop through and pop 'em off
    for my $i (1..$max_arr) {
        my @row = ();

        foreach my $key (sort keys %{$data}) {
            my $value = pop @{$data->{$key}};

            push @row, $value;
        }
        push @{$rv}, \@row;
    }

    return $rv;
}

sub make_points_graph {
    my($data) = @_;

    my $graph = GD::Graph::points->new( 800, 600 );

    $graph->set(
        x_label             => 'URI',
        x_labels_vertical   => 1,
        y_label             => 'response (sec)',
        title               => 'XTracker Response Times',
        transparent         => 0,
        fgclr               => 'black',
        axislabelclr        => 'black',
       # y_max_value     => 10,
    ) or die $graph->error;

    open(my $IMG,'>','xt_response.png') or die $!;
    binmode $IMG;
#    print IMG $gd->png;
    print $IMG $graph->plot( retrieve_graph_data($data) )->png;
    close $IMG;

    return;
}

sub calculate_figures {
    my $data = shift;

    my $parsed_data;

    foreach my $log_entry ( @{$data} ) {

        if ( $log_entry->{content} =~ /(\S+)\s(\S+)s$/ ) {

            # New uri initialise values
            if ( not exists $parsed_data->{$1} ) {
                $parsed_data->{$1}->{'sum'} = $2;
                $parsed_data->{$1}->{'max'} = $2;
                $parsed_data->{$1}->{'min'} = $2;
            }
            else {

                # If max set max
                if ( $2 > $parsed_data->{$1}->{'max'} ) {
                    $parsed_data->{$1}->{'max'} = $2;
                }

                # If min set min
                elsif ( $2 < $parsed_data->{$1}->{'min'} ) {
                    $parsed_data->{$1}->{'min'} = $2;
                }

                # Add to sum and increase count
                $parsed_data->{$1}->{'sum'} += $2;
            }
            push @{ $parsed_data->{$1}->{'data'} }, $2;
        }
    }

    return $parsed_data;
}

sub max_array_size {
    my $data = shift;

    my $max_arr = 0;

    foreach my $key (keys %{$data}) {
        if (scalar @{$data->{$key}->{'data'}} > $max_arr) {
            $max_arr = scalar @{$data->{$key}->{'data'}};
        }
    }

    return $max_arr;
}

sub make_array {

    my $data = shift;
    my @uri;
    my @start;
    my @min_block;
    my @max_block;
    my $points;
    my @formatted_array;

    my $max_arr = max_array_size ( $data );

    my $uri_number = 0;

    foreach my $uri ( sort keys %{$data} ) {
        my $avg = $data->{$uri}->{'sum'}/(scalar @{ $data->{$uri}->{'data'} });
        push @uri, $uri;
        push @start, $data->{$uri}->{'min'};
        push @min_block, $avg - $data->{$uri}->{'min'};
        push @max_block, $data->{$uri}->{'max'} - $avg;
        
        my $counter = 0;
        for (@{$data->{$uri}->{'data'}}) {
            push @{$points->[$counter]}, $_;
            $counter++;
        }
        while ($counter < $max_arr) {
            push @{$points->[$counter]}, undef;
            $counter++;
        }
        $uri_number++;
    }

    push @formatted_array, \@uri;
    push @formatted_array, \@start;
    push @formatted_array, \@min_block;
    push @formatted_array, \@max_block;
    foreach (@{$points}) {
        push @formatted_array, $_;
    }

    print pp(@formatted_array);

    return \@formatted_array;

}

sub make_stats_graph {
    my( $data, $max) = @_;

    my $graph = GD::Graph::mixed->new( 1024, 768 );

    my $types = [ qw(area bars bars) ];
    my $dclrs = [ undef, qw(green red) ];
    my $borderclrs = [ undef, ];

    my $i = 0;
    while ( $i < scalar( @{$data} ) - 3 ) {
        push @{$types}, 'points';
        push @{$dclrs}, 'black';
        $i++;
    }

    $i=0;
    while ( $i < scalar( @{$data} ) - 1 ) {
        push @{$borderclrs}, 'black';
        $i++;
    }


    $graph->set(
        x_label             => 'URI',
        x_labels_vertical   => 1,
        y_label             => 'response (sec)',
        y_min_value         => 0,
        y_max_value         => $max,
        title               => 'XTracker Response Times',
        transparent         => 0,
        cumulate            => 1,
        types               => $types,
        dclrs               => $dclrs,
        borderclrs          => $borderclrs,
        fgclr               => 'black',
        axislabelclr        => 'black',
    ) or die $graph->error;

    $graph->set( markers => [4] );
    $graph->set_legend(undef, qw(MIN MAX));

    open(my $IMG,'>','xt_response.png') or die $!;
    binmode $IMG;
#    print IMG $gd->png;
    print $IMG $graph->plot( $data )->png;
    close $IMG;

    return;
}


sub main {

    my $data = parse_input;
    
    my $by_uri = bias_by_uri( $data );

    my $hash_data = calculate_figures( $data );
    my $array_data = make_array( $hash_data );
    my $y_max = 0;
    foreach my $uri (keys %{$hash_data}) {
        if ( $hash_data->{$uri}->{'max'} > $y_max ) {
            $y_max = int( $hash_data->{$uri}->{'max'} ) + 1;
        }
    }
    make_stats_graph( $array_data, $y_max );

    #print pp($array_data);
#    print Dumper( $by_uri );
    #make_points_graph( $by_uri );
}

main;
