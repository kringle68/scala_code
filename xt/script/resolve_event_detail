#!/opt/xt/xt-perl/bin/perl
use strict;
use warnings;

use lib qw( /opt/xt/deploy/xtracker/lib );
use FindBin::libs qw( base=lib_dynamic );
use Text::CSV;
use IO::File;
use Readonly;
use SQL::Abstract;
use Data::Dump qw/pp/;

use XTracker::Database qw( :common );
use XTracker::Constants::FromDB qw(:event_type);

my %fix_sql;

local $|=1;

Readonly my %dbconfnames => (
    xtracker    => 'xtracker_schema',
    nap_intl    => 'pws_schema_Intl',
    nap_am      => 'pws_schema_AM',
    out_intl    => 'pws_schema_OUT-Intl',
    out_am      => 'pws_schema_OUT-AM',
);

Readonly my @webnames => (qw/
    nap_intl nap_am out_intl out_am
/);

Readonly my %issues => (
 1 => 'recreate event in xtracker and update website with new event id',
 2 => 'update website id to same as xtracker',
 3 => 'work out which is real',
 4 => 'weird',
 5 => 'create new record on xtracker and update websites event id',
 6 => 'update web record with full internal name',
);

Readonly my @colnames => ( qw/
    id
    visible_id
    internal_title
    start_date
    end_date
    enabled
    discounted_type
    discount_percentage
    discount_pounds
    discount_eurios
    discount_dollars
    coupon_prefix
    coupon_restriction_id
    price_group_id
    basket_trigger_pounds
    basket_trigger_euros
    basket_trigger_dollars
    title
    subtitle
    created
    created_by
    last_modified
    last_modified_by
    target_city_id
    coupon_target_id
    coupon_generation_id
    status_id
    been_exported
    exported_to_lyris
    coupon_custom_limit
    restrict_by_weeks
    restrict_x_weeks
    event_type_id
    product_page_visible
    always_visible
    publish_date
    announce_date
    close_date
    publish_to_announce_visibility
    announce_to_start_visibility
    start_to_end_visibility
    end_to_close_visibility
    publish_method_id
    target_value
    target_currency
    end_price_drop_date
    description
    dont_miss_out
    sponsor_id
/);

my $event = { };
my $case = { };
my $internal_title = { };
my $max_id = undef;
my $dbs = undef;

sub retrieve_databases {
    my $dbs = undef;
    foreach my $name (keys %dbconfnames) {
        $dbs->{$name} = get_database_handle({
            name => $dbconfnames{$name},
            type => 'transaction',
        });
    }
    return $dbs;
}

sub retrieve_max_id {
    my($dbs) = @_;
    my $max_id = 0;

    foreach my $name (@webnames) {

    my $id = $dbs->{$name}->resultset('Detail')->search({
                'me.id' => { '<' => 300},
            })
            ->get_column('id')->max;

        $max_id = $id if ($id > $max_id);
    }

    return $max_id;
}

sub get_website_id {
    my($rec) = @_;

    my $rs = $rec->result_source->schema->resultset('DetailWebsites')->search(
        {
            event_id => $rec->id,
        }
    );

    if ($rs->count == 1) {
        return $rs->single->website_id;
    } elsif ($rs->count > 1) {
        warn "More than one website!!";
        return 'WARN';
    }
    return '';
}

sub process_website {
    my($xt,$web,$name) = @_;
    my $fixes = undef;

    my $detail_rs = $web->resultset('Detail')->search(
        {
        },
        {
            order_by => 'me.id',
        }
    );

    return if (not defined $detail_rs or $detail_rs->count == 0);

    my $failed = 0;
    while (my $rs = $detail_rs->next) {
        my $new_title = 0;
        my $event = $xt->resultset('Promotion::Detail')->find( $rs->id );

        if (defined $internal_title->{$rs->internal_title}
            and $name !~ /^nap/i) {
            print "  ". $rs->id ." - WARNING: duplicate internal title - "
                . $rs->internal_title ."\n";

            my $fresh_title = $rs->internal_title;
            do {
                $fresh_title = $name ." ". $fresh_title;
            } while (defined $internal_title->{$fresh_title});

            $internal_title->{$fresh_title} = $rs->id;
            print "    fresh title: $fresh_title\n";

            $new_title = 1;
        } else {
            $internal_title->{$rs->internal_title} = $rs->id;
        }

        if (not defined $event) {
        #    print "  ". $rs->id ." - Cannot find id in xtracker\n";

            $event = $xt->resultset('Promotion::Detail')->search(
                {
                    internal_title => $rs->internal_title,
                }
            );

            if (not defined $event or $event->count == 0) {
                print "  CASE1:". $rs->id ." - Cannot find event in xtracker\n";

                # CASE 1:
                push @{$fixes}, {
                    name    => $name,
                    type => 1,
                    webrec => $rs,
                };

                $case->{1}++;
                $failed++; next;

            } elsif ($event->count == 1) {
            print "  CASE2:". $rs->id ." - OK - not id match - "
                    . $event->id ."\n";
                # CASE 2:
                $case->{2}++;
                $failed++; next;

            } elsif ($event->count > 1) {
            print "  CASE3:". $rs->id ." - more than one match "
                    . $event->id ."\n";
                # CASE 3:
                $case->{3}++;
                $failed++; next;

            } else {
                print "  CASE4:". $rs->id ." - DUNNO\n";
                # CASE 4: weird
                $case->{4}++;
                $failed++; next;

            }
        } else {
        if ($event->internal_title ne $rs->internal_title) {
                my $substr = $rs->internal_title;

        if ($event->internal_title =~ /$substr/) {
                    print "  CASE6:". $rs->id 
                        ." - fix truncated internal title\n";

                    # CASE 6:
                    push @{$fixes}, {
                        id      => $event->id,
                        name    => $name,
                        type    => 6,
                        webrec  => $rs,
                        internal_title => $event->internal_title,
                    };
                    $case->{6}++;
                $failed++; next;
                } else {
                    print "  CASE5:". $rs->id 
                        ." - internal title does not match\n    "
                    ."'". $event->internal_title ."' vs '"
                        . $rs->internal_title ."'\n";

                    # CASE 5:
                    push @{$fixes}, {
                        id      => $event->id,
                        name    => $name,
                        type => 5,
                        webrec => $rs,
                    };
                    $case->{5}++;
                $failed++; next;
                }

            } else {
                # all good
            }
        }
    }
    return ($failed,$fixes);
}

sub get_confirm {
    return 1;
    ## no critic(ProhibitUnreachableCode)
    my($mesg) = @_;

    do {
        print STDERR $mesg;
        my $input = (<STDIN>); ## no critic(ProhibitExplicitStdin)

        if ($input =~ /^y/i) {
            return 1;
        } elsif ($input =~ /^n/i) {
            return 0;
        }
        
    } while (1);
}

sub get_next_id {
    if ($max_id + 1 >299) {
        die "Out of ids!!!";
    }
    return ++$max_id;
}

sub data_as_hash {
    my($rec) = @_;

    my %data = $rec->get_columns;
    return \%data;
}

sub convert_date {
    my($date) = @_;
}

# CASE 1: recreate event in xtracker
sub fix_case_1 {
    return;
    ## no critic(ProhibitUnreachableCode)
    my($fix) = @_;
}

# CASE 5: create new record on xtracker and update id on website
sub fix_case_5 {
    my($fix) = @_;
    my ($stmt, @bind, $join_data);
    my $schema_xt = $dbs->{xtracker};
    my $schema_web = $fix->{webrec}->result_source->schema;
    my $id = get_next_id; # the next ID to use for a "fixed up" event

    my $data = data_as_hash($fix->{webrec});
    my $original_id = $data->{id};
    $data->{id} = $id;
    $data->{target_city_id} = 1;
    #print "TYPE: $data->{event_type_id}\n";
    my $type_id = $data->{event_type_id};

    foreach my $field (qw/publish_date announce_date start_date
        end_price_drop_date end_date close_date/) {
        # convert the mysql London time into utc time in $data
        # XXX if anything use "SET time_zone = ?"
    }

    # create the event in XTDC
    my $sql = SQL::Abstract->new;
    ($stmt, @bind) = $sql->insert(
        'event.detail',
        $data,
    );

    $stmt = sqlify($stmt, \@bind);

    if ($stmt =~ m{ \?[,)]}) {
        warn "$stmt\n";
        die pp $data;
    }

    push @{$fix_sql{xtdc1}{CASE_5}}, $stmt;

    # get any product limitations and add to XTDC1
    my $rs = $schema_web->resultset('DetailProduct')
        ->search({ event_id => $original_id, });
    while (my $row = $rs->next) {
        $join_data = data_as_hash( $row );

        $join_data->{id} = \'default';
        $join_data->{event_id} = $id;

        ($stmt, @bind) = $sql->insert(
            'event.detail_products',
            $join_data,
        );
        $stmt = sqlify($stmt, \@bind);
        push @{$fix_sql{xtdc1}{CASE_5}}, $stmt;

    }


    # update the id on the PWS
    ($stmt, @bind) = $sql->update(
        'event_detail',
        { id => $id },
        { id => $original_id },
    );
    $stmt = sqlify($stmt, \@bind);
    push @{$fix_sql{$fix->{name}}{CASE_5}}, $stmt;

    
    return;
}

# CASE 6: update web record with full internal name
sub fix_case_6 {
    my($fix) = @_;

    my $sql = SQL::Abstract->new;

    my($stmt, @bind) = $sql->update(
        'event_detail',
        { internal_title => $fix->{internal_title} },
        { id => $fix->{id} },
    );

    $stmt = sqlify($stmt, \@bind);
    push @{$fix_sql{$fix->{name}}{CASE_6}}, $stmt;
    return;
}

# can't find anything that will replce bind placeholders and bive me the SQL
# - CCW
sub sqlify {
    my ($stmt, $bind) = @_;
    my $schema = $dbs->{xtracker};
    my $dbh = $schema->storage()->dbh();

    foreach my $bindvar (@$bind) {
        my $quoted = $dbh->quote($bindvar);
        next
            if ($stmt =~ s{(\()\?(, )}{$1$quoted$2});

        next
            if($stmt =~ s{([ ])\?([,) ])}{$1$quoted$2});
    }

    return "$stmt;";
}

sub spew_sql {
    my $io;
    if (defined $ARGV[1]) {
        $io = IO::File->new;
        $io->open("> $ARGV[1]");
    }
    else {
        $io = \*STDOUT;
    }

    # loop through each site
    foreach my $site (sort keys %fix_sql) {
        my $return_sp_fail = q{-- DEFAULT sp_fail REVERT TEXT};

        print $io "--\n-- Site: $site\n--\n";
        print $io "BEGIN;\n\n";

        # we only *need* this for CASE_5
        if (exists $fix_sql{$site}{CASE_5}) {
            print $io "-- Add 'ON UPDATE CASCADE' to foreign keys\n";
            print $io event_id_constraint_fix(), "\n";
        }

        # loop through each case
        foreach my $case (keys %{$fix_sql{$site}}) {
            my $case_number = $case; $case_number =~ s/\A.+(\d+)\z/$1/;
            print $io "\n\n-- $site : $case : $issues{$case_number}\n\n";
            # loop through all the queued SQL statements
            foreach my $sql (@{$fix_sql{$site}{$case}}) {
                print $io "$sql\n";
            }
        }

        # ROLLBACK unless ARGV[0] says commit
        if (defined $ARGV[0] and $ARGV[0] =~ m{\Acommit\z}i) {
            print $io "\nCOMMIT;"
        }
        else {
            print $io "\nROLLBACK;"
        }
        print $io " -- END:  Site: $site\n\n\n";
    }
}

sub event_id_constraint_fix {
    return <<"EOSQL";
-- event_product table
ALTER TABLE event_product DROP FOREIGN KEY `fk_event_product_1`;
ALTER TABLE event_product ADD CONSTRAINT `fk_event_product_1`
    FOREIGN KEY (`event_id`)
    REFERENCES `event_detail` (`id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE;
-- event_customer table
ALTER TABLE event_customer DROP FOREIGN KEY `fk_event_customer_1`;
ALTER TABLE event_customer ADD CONSTRAINT `fk_event_customer_1`
    FOREIGN KEY (`event_id`)
    REFERENCES `event_detail` (`id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE;
-- event_applied table
ALTER TABLE event_applied DROP FOREIGN KEY `FK_event_applied_2`;
ALTER TABLE event_applied ADD CONSTRAINT `FK_event_applied_2`
    FOREIGN KEY (`promotion_id`)
    REFERENCES `event_detail` (`id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE;
-- reverse_auction_best_prices
ALTER TABLE reverse_auction_best_prices DROP FOREIGN KEY `reverse_auction_key`;
ALTER TABLE reverse_auction_best_prices ADD CONSTRAINT `reverse_auction_key`
    FOREIGN KEY (`event_id`)
    REFERENCES `event_detail` (`id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE;
-- event_applied_item
ALTER TABLE event_applied_item DROP FOREIGN KEY `fk_event_applied_item_1`;
ALTER TABLE event_applied_item ADD CONSTRAINT `fk_event_applied_item_1`
    FOREIGN KEY (`order_id`, `promotion_id`)
    REFERENCES `event_applied` (`order_id`, `promotion_id`)
    ON DELETE CASCADE
    ON UPDATE CASCADE;
EOSQL
}

$dbs = retrieve_databases();
my $total = 0; 
my $web_max_id = retrieve_max_id($dbs);
my $xt_max_id = $dbs->{xtracker}->resultset('Promotion::Detail')->search({
    'me.id' => { '<' => 300}, })
    ->get_column('id')->max;
$max_id = ($web_max_id > $xt_max_id) ? $web_max_id : $xt_max_id;

print STDERR<<END;
   web: $web_max_id
    xt: $xt_max_id
   max: $max_id
END

my $fixes;
foreach my $name (@webnames) {
    print "name: $name\n";
    my($failed,$fix_me) = process_website(
        $dbs->{xtracker},
        $dbs->{$name},
        $name
    );
    print "name: $name - $failed failed\n";

    push @{$fixes}, @{$fix_me} if (defined $fix_me and ref($fix_me) eq 'ARRAY');
    $total += $failed;
}

foreach my $issue (sort keys %{$case}) {
    print STDERR "CASE $issue: $case->{$issue} - $issues{$issue}\n";
}

print "Total $total failed\n";
print STDERR "Total $total failed\n";

exit if (not get_confirm('Do you want to attempt to fix issues? (y/n) '));
die "No fix information to fix with"
    if (not defined $fixes or scalar @{$fixes} < 1);

my $fixed = 0;
foreach my $fix (@{$fixes}) {
    my $type = (defined $fix->{type}) ? $fix->{type} : undef;
    next if (not defined $fix->{type});

    if ($type == 1) {
#        fix_case_1($fix);
    } elsif ($type == 5) {
        fix_case_5($fix);
    } elsif ($type == 6) {
        if (fix_case_6($fix)) {
            $fixed++;
        }
    }
}
#pp \%fix_sql;
spew_sql();
print STDERR "  Fixed $fixed/". scalar @{$fixes} ."\n";
