#!/opt/xt/xt-perl/bin/perl

=head1 NAME

generate_inventory_csv - Generate a CSV file with data to import into IWS/XT

=head1 SYNOPSIS

perl generate_inventory_csv --jc_dbname jc_dbname --jc_host host -s source_csv_file -t target_csv_file

=head1 ARGUMENTS

=over

=item --jc_dbname

The name of the Jimmy Choo database

=item --jc_host

The host the Jimmy Choo database lives on

=item --source_csv_file -s

The CSV file that contains the SKU mappings from JC to XT.

=item --target_csv_file -t

The name of the CSV file to be created.

=back

=cut

use NAP::policy "tt";

use DBI;
use FindBin::libs;
use FindBin::libs qw( base=lib_dynamic );
use Getopt::Long;
use Pod::Usage;
use Text::CSV_XS;

use Data::Dump 'pp';

my $result = GetOptions(
    'jc_dbname=s'         => \(my $db_name),
    'jc_host=s'           => \(my $host),
    'source_csv_file|s=s' => \(my $source_filename),
    'target_csv_file|t=s' => \(my $target_filename),
    'help|h' => \(my $help),
);

pod2usage(-verbose => 1)
    if (!$result || $help);

for (
    [ 'jc_dbname',       $db_name         ],
    [ 'jc_host',         $host            ],
    [ 'source_csv_file', $source_filename ],
    [ 'target_csv_file', $target_filename ],
) {
    my ( $key, $value ) = @$_;
    if ( !$value ) {
        say "You need to provide a $key";
        pod2usage(-verbose => 1);
    }
}

print_csv($target_filename, get_jc_inventory(), sku_map($source_filename));

exit;

sub print_csv {
    my ( $filename, $inventory, $map ) = @_;

    my $csv = Text::CSV_XS->new({binary => 1, diag_verbose => 1, eol => $/});
    my @cols = (qw/sku location quantity channel allowed_status/);

    print 'Writing csv file...';
    my @missing_skus;
    open(my $fh, '>:encoding(utf8)', $filename)
        or die "Could not open $filename for writing: $!";

    $csv->print($fh, \@cols);
    for my $source_sku (keys %$map) {
        my $destination_sku = $map->{$source_sku};
        unless ( $destination_sku ) {
            push @missing_skus, $source_sku;
            next;
        }
        for my $location ( keys %{$inventory->{$source_sku}} ) {
            $csv->print($fh, [
                $destination_sku,
                $location,
                $inventory->{$source_sku}{$location},
                'JIMMYCHOO.COM',
                'main', # as far as we can tell, importing only location_type 'DC1' means only importing main stock
            ]);
    }
    }
    close $fh;
    say sprintf( q{Couldn't find mapping for SKU%s: %s},
        (@missing_skus == 1 ? q{} : q{s}), join q{, }, sort @missing_skus
    ) if @missing_skus;
    say 'done';
}

sub sku_map {
    my $filename = shift;
    my $csv = Text::CSV_XS->new({binary => 1, diag_verbose => 1});

    print "Parsing $filename...";
    open(my $fh, '<:encoding(utf8)', $filename)
        or die "Couldn't open file $filename: $!\n";

    my @cols = $csv->getline($fh); # skip the first line
    $csv->column_names(@cols);
    my %map;
    while ( my $row = $csv->getline_hr($fh) ) {
        next unless $row->{errored} eq 'No';
        my ( $source_sku, $destination_sku ) = map {
            sprintf '%d-%03d', @{$row}{@{$_}[0..1]}
        } [qw/source_pid source_size_id/],[qw/destination_pid destination_size_id/];
        # Do we need this warn?
        warn "Found duplicate entry for $source_sku" if exists $map{source_sku};
        die "$row->{source_sku} maps to two different SKUs"
            if $map{$source_sku} && $map{$source_sku} ne $destination_sku;
        $map{$source_sku} = $destination_sku;
    }
    $csv->eof or $csv->error_diag;
    close $fh;
    say 'done';
    return \%map;
}

sub get_dbh {
    my $data_source = "dbi:Pg:dbname=${db_name};host=$host";
    my $username = 'www';
    my $password = 'www';
    return DBI->connect($data_source, $username, $password) or die $DBI::errstr;
}

sub get_jc_inventory {
    my %jc_inventory;
    for my $row (
        @{get_dbh()->selectall_arrayref(main_stock_query(), { Slice => {} })}
    ) {
        $jc_inventory{$row->{sku}}{$row->{location}} += $row->{quantity};
    }
    return \%jc_inventory;
}

sub main_stock_query {
    return <<EOQ
    SELECT
        v.product_id || '-' || LPAD(CAST(v.size_id AS VARCHAR), 3, '0') as sku,
        l.location as location,
        q.quantity
    FROM quantity q
    JOIN variant v ON v.id = q.variant_id
    JOIN location l ON l.id = q.location_id
    JOIN location_type lt ON l.type_id = lt.id
    JOIN product p ON p.id = v.product_id
    WHERE lt.type = 'DC1'
    ORDER BY sku, location
EOQ
;
}
