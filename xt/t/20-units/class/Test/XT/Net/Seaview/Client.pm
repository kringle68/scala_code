package Test::XT::Net::Seaview::Client;

use NAP::policy "tt", 'test', 'class';

BEGIN {
    extends "NAP::Test::Class";
};

use Data::UUID;

use Test::XTracker::Data;
use XTracker::Config::Local qw/config_var/;
use XT::Data::Customer::Account;
use XT::Data::Customer;
use XT::Data::Address;

use XT::Net::Seaview::Client;

=head1 DESCRIPTION

Tests the basic methods of the Seaview client. If the config value
Seaview:useragent_class is set to XT::Net::Seaview::TestUserAgent then these
tests will run against a set of canned responses generated by that class. If
the useragent_class is set to LWP::UserAgent then the tests will run against
a running service instance located at Seaview:service_url

=cut

sub _schema : Test(startup) {
    my $self = shift;
    $self->{schema} = Test::XTracker::Data->get_schema;
}

sub _seaview_client : Test(startup) {
    my $self = shift;

    use_ok 'XT::Net::Seaview::TestUserAgent';
    $self->{test_user_agent} = 'XT::Net::Seaview::TestUserAgent';

    $self->{seaview}
      = XT::Net::Seaview::Client->new(
          { schema  => $self->{schema},
            useragent_class => config_var("Seaview", "useragent_class"),
          });

    if(ref $self->{seaview}->useragent
         eq 'XT::Net::Seaview::TestUserAgent'){
        $self->{test_ua} = 1;
    }
}

sub customer : Test(startup) {
    my $self = shift;

    $self->{addr_schema}
      = Test::XTracker::Data->create_order_address_in('DC1');
}

sub test_account : Tests {
    my $self = shift;

    # Create a database customer
    my $data = Test::XT::Data->new_with_traits(
        traits  => [ 'Test::XT::Data::Customer',
                     'Test::XT::Data::Channel', ], );

    # Check the local data
    is( $data->customer->title, 'Mr',
        q/First name is 'Mr' as expected pre-update/);

    is( $data->customer->first_name, 'Joe',
        q/First name is 'Joe' as expected pre-update/);

    is( $data->customer->last_name, 'Bloggs',
        q/Last name is 'Bloggs' as expected pre-update/);

    is( $data->customer->category->category, 'None',
        q/Category is 'None' as expected pre-update/);

    $self->{account}
      = XT::Data::Customer::Account->new($self->_account_data);

    # Add account to Seaview
    $self->{account_urn} = $self->{seaview}->add_account($self->{account});

    ok($self->{account_urn},
       "Seaview account added: $self->{account_urn}");

    # Find the linked customer
    $self->{customer_urn}
      = $self->{seaview}->discover_customer_urn($self->{account_urn});

    # Test Seaview customer/account interactions
    ok($self->{customer_urn},
       "Seaview account has customer: $self->{customer_urn}");

    is($self->{customer_urn},
       $self->{seaview}->discover_customer_urn($self->{customer_urn}),
       'Discover customer via customer_urn is consistent');

    is($self->{customer_urn},
       $self->{seaview}->find_customer($self->{account_urn}),
       'Find customer via account_urn is consistent');

    # Add global id to XT customer record
    ok($self->{seaview}
            ->link_customer($data->customer->id, $self->{account_urn}),
       'XT customer can be linked to Seaview account');

    # Find the local linked customer
    my $xt_account_urn
      = $self->{seaview}->registered_account($data->customer->id);

    is($xt_account_urn, $self->{account_urn},
       'XT customer and Seaview account is linked');

    # Account information
    my $account = $self->{seaview}->account($self->{account_urn});
    isa_ok($account, 'XT::Data::Customer::Account');

    # The database has been updated. Ensure we pick up the changes
    $data->customer->discard_changes;

    # Check the local data *after* we've requested it from Seaview (it should
    # have been updated)
    is( $data->customer->title, $account->title,
          q/Title is '/ . $account->title
        . q/' as expected post-update/);

    is( $data->customer->first_name, $account->first_name,
          q/First name is '/ . $account->first_name
        . q/' as expected post-update/);

    is( $data->customer->last_name, $account->last_name,
          q/Last name is '/ . $account->last_name
        . q/' as expected post-update/);

    is( $data->customer->category->category, $account->category,
          q/Category is '/ . $account->category
        . q/' as expected post-update/);

    # Account headers object
    isa_ok($self->{seaview}->account_meta($self->{account_urn}),
           'HTTP::Headers');

}

sub test_address : Tests {
    my $self = shift;

    my $data_obj = $self->{addr_schema}->as_data_obj;
    $data_obj->account_urn($self->{account_urn});
    $data_obj->address_type('Shipping');

    # Add address to Seaview
    $self->{address_urn} = $self->{seaview}->add_address($data_obj);

    ok($self->{address_urn}, 'New address is created');

    # Seaview address as an XT::Data object
    my $sv_addr_data_obj = $self->{seaview}->address($self->{address_urn});

    is($sv_addr_data_obj->urn, $self->{address_urn},
       "Seaview address added correctly: $self->{address_urn}");

    # Link the local address
    $self->{addr_schema}->urn($self->{address_urn});
    $self->{addr_schema}->last_modified($sv_addr_data_obj->last_modified);
    $self->{addr_schema}->update;

    # Check the link
    is($self->{seaview}->registered_address($self->{addr_schema}->id),
       $self->{address_urn},
       'XT Address is linked to Seaview');

    # Update the local db record
    $self->{addr_schema}->first_name('New first name');

    # Create new data object
    my $new_addr_data_obj = $self->{addr_schema}->as_data_obj;

    lives_ok(sub {$self->{seaview}->update_address($self->{address_urn},
                                                   $new_addr_data_obj)},
             'Seaview address can be updated');

    my @addresses = $self->{seaview}->all_addresses($self->{account_urn});

    ok(@addresses >= 1, 'We can retrieve addresses');

}

sub test_caches : Tests {
    my $self = shift;

    lives_ok( sub { $self->{seaview}->clear_caches },
              'Caches can be cleared');

    ok(keys %{$self->{seaview}->addresses->cache} == 0,
       'Address cache is empty');

    ok(keys %{$self->{seaview}->accounts->cache} == 0,
       'Accounts cache is empty');

    ok(keys %{$self->{seaview}->customers->cache} == 0,
       'Customer cache is empty');

    my @addresses = $self->{seaview}->all_addresses($self->{account_urn});

    ok(keys %{$self->{seaview}->customers->cache} > 0,
       'Customer cache is populated');

    ok(keys %{$self->{seaview}->accounts->cache} > 0,
       'Account cache is populated');

    ok(keys %{$self->{seaview}->addresses->cache} > 0,
       'Address cache is populated');

}

sub test_booleans : Tests {
    my ($self) = @_;

    # Test setting Boolean flag
    my $data_obj = $self->{seaview}->account($self->{account_urn});

    # Account contains default flags
    ok(!$data_obj->welcome_pack_sent, '\'Welcome pack\' flag is false (default)');
    ok(!$data_obj->porter_subscriber, '\'Porter Subscriber\' flag is false (default)');

    lives_ok(
        sub {$self->{seaview}->update_welcome_pack_flag($self->{account_urn},
                                                        1,
                                                        0)},
        'Seaview welcome pack flag can be updated');

    lives_ok(
        sub {$self->{seaview}
                  ->update_porter_subscriber_flag($self->{account_urn},
                                                  1,
                                                  0)},
        'Seaview porter subscriber flag can be updated');

    # Undefine the data object so we don't accidentally re-use it
    $data_obj = undef;

    # Refetch account information
    my $data_obj2 = $self->{seaview}->account($self->{account_urn});

    SKIP: {
          skip "Don't test updates with test UA", 2 if $self->{test_ua};
          ok($data_obj2->welcome_pack_sent,
             '\'Welcome pack\' flag is set true remotely');
          ok($data_obj2->porter_subscriber,
             '\'Porter Subscriber\' flag is set true remotely');
    }
}

sub test_get_card_token : Tests {
    my $self = shift;

    my $account
      = XT::Data::Customer::Account->new( $self->_account_data );

    # Add account to Seaview
    my $account_urn = $self->{seaview}->add_account( $account );

    ok( $account_urn,
        "Seaview account added: $account_urn" );

    my $expected_card_token = undef;
    if($self->{test_ua}){
        # Card token from the canned json response
        $expected_card_token = 'ae51266b7f88867bf8de9749d0905683';
    }
    else{
        # We're going to stuff this in the service
        $expected_card_token = 'testcardtoken';
    }

    # Replace the card token
    $self->{seaview}->replace_card_token( $account_urn, { card_token => $expected_card_token });

    # Get the card token.
    my $token = $self->{seaview}->get_card_token( $account_urn );

    # Make sure it's the right object.
    isa_ok( $token,
        'XT::Net::Seaview::Representation::CardToken::JSONLD',
        'Card token' );

    # .. and it's the right token.
    cmp_ok( $token->card_token,
        'eq',
        $expected_card_token,
        'Got the correct card token' );
}

sub _account_data {
    my ($self, $overrides) = @_;

    my $account =
      { email              => 'xtclient-test-' . int(rand(1000)) . '@net-a-porter.com',
        encrypted_password => 'my new password',
        title              => 'Miss',
        first_name         => 'Test First Name ' . int(rand(1000)),
        last_name          => 'Test Last Name ' . int(rand(1000)),
        country_code       => 'GB',
        origin_id          => 666, # Magic client id - unvalidated
        origin_region      => 'DC1',
        origin_name        => 'XT',
        date_of_birth      => DateTime->now(),
        schema             => $self->{schema},
      };

    @{$account}{keys %{$overrides}} = values %{$overrides};

    return $account;
}

sub test_get_bosh_value_for_account : Tests {
    my $self = shift;

    throws_ok(
        sub { $self->{seaview}->get_bosh_value_for_account( 'urn:nap:account:test_urn' ) },
        qr/Key not supplied/,
        'Missing "key" throws the exception "Key not supplied"' );

    throws_ok(
        sub { $self->{seaview}->get_bosh_value_for_account },
        qr/URN not supplied/,
        'Missing "urn" throws the exception "URN not supplied"' );

    $self->{test_user_agent}->clear_response_queue('customer_bosh_GET');
    $self->{test_user_agent}->add_to_response_queue( customer_bosh_GET => 200 );
    $self->{test_user_agent}->clear_last_customer_bosh_GET_request;

    my $result       = $self->{seaview}->get_bosh_value_for_account( 'urn:nap:account:test_urn', 'test_key' );
    my $last_request = $self->{test_user_agent}->get_last_customer_bosh_GET_request;

    isa_ok( $result,
        'XT::Net::Seaview::Representation::BOSH::Text',
        'The result of calling get_bosh_value_for_account' );

    # The 'Test Vale' comes from the t/data/seaview/customer_bosh_GET_200.response file.
    cmp_ok( $result->value,
        'eq', 'Test Value',
        'The value returned is "Test Value"' );

    cmp_deeply( $last_request, [
        # Should be an HTTP::Request object.
        methods(
            content => '',
            uri     => methods(
                as_string => re( qr|/bosh/account/test_urn/test_key| ),
            ),
        ),
        {
            urn => 'test_urn',
            key => 'test_key',
        } ] );

}

sub test_replace_bosh_value_for_account : Tests {
    my $self = shift;

    throws_ok(
        sub { $self->{seaview}->replace_bosh_value_for_account( 'urn:nap:account:test_urn' ) },
        qr/Key not supplied/,
        'Missing "key" throws the exception "Key not supplied"' );

    throws_ok(
        sub { $self->{seaview}->replace_bosh_value_for_account },
        qr/URN not supplied/,
        'Missing "urn" throws the exception "URN not supplied"' );

    $self->{test_user_agent}->clear_response_queue('customer_bosh_PUT');
    $self->{test_user_agent}->add_to_response_queue( customer_bosh_PUT => 200 );
    $self->{test_user_agent}->clear_last_customer_bosh_PUT_request;

    my $result       = $self->{seaview}->replace_bosh_value_for_account( 'urn:nap:account:test_urn', 'test_key', 'test_value' );
    my $last_request = $self->{test_user_agent}->get_last_customer_bosh_PUT_request;

    cmp_ok( $result,
        'eq', 'urn:nap:account:test_urn:bosh:test_key',
        'The value returned is "urn:nap:account:test_urn:bosh:test_key"' );

    cmp_deeply( $last_request, [
        # Should be an HTTP::Request object.
        methods(
            content => 'test_value',
            uri     => methods(
                as_string => re( qr|/bosh/account/test_urn/test_key| ),
            ),
        ),
        {
            urn => 'test_urn',
            key => 'test_key',
        } ] );

}
