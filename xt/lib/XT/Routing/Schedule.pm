package XT::Routing::Schedule;
use NAP::policy "tt", 'class';
use XT::Data::Types qw();
use MooseX::Types::Moose            qw( Str Int ArrayRef );
use MooseX::Types::Structured       qw( Dict );

use XTracker::Logfile               qw( xt_logger );

use Carp;
use Data::Dump                      qw( pp );

use XTracker::Database              qw( get_database_handle );
use XTracker::Constants::FromDB     qw(
                                        :routing_schedule_type
                                    );
use XTracker::Config::Local         qw(
                                        config_var
                                        config_section_slurp
                                        order_nr_regex
                                    );
with 'XTracker::Role::WithAMQMessageFactory';

has schema => (
    is          => 'rw',
    isa         => 'DBIx::Class::Schema|XTracker::Schema|XT::DC::Messaging::Model::Schema',
    lazy_build  => 1,
);

has alerts_to_send => (
    is          => 'rw',
    isa         => ArrayRef[
                    Dict[
                        rec_class   => Str,
                        id          => Int,
                    ],
                ],
    default     => sub { return []; },
    traits      => ['Array'],
    handles     => {
                number_of_alerts    => 'count',
                add_to_alerts       => 'push',
                get_next_alert      => 'shift',
            },
);

sub _build_schema {
    my $self    = shift;

    return get_database_handle( { name => 'xtracker_schema' } );
}

=head2 parse_file_content

    $hash_ref   = $self->parse_file_content( $hash_ref );

This parses a HASH Ref which has been generated by the use of 'XML::Simple::XMLIn()' method which
returns a HASH Ref representing the XML File contents.

=cut

sub parse_file_content {
    my ( $self, $file_content ) = @_;

    my $content;

    # the nodes to get out of the XML
    # and the name to call them
    my %to_get  = (
            orderid         => 'external_id',
            orderref        => 'nap_ref',
            shipmentno      => 'shipment_id',
            driver          => 'driver',
            coldeldate      => 'delivery_window_date',
            coldeltime      => 'delivery_window',
            runno           => 'run_number',
            runorderno      => 'run_order_number',
            status          => 'status',
            sig             => 'signatory',
            sigdate         => 'sig_date',
            sigtime         => 'sig_time',
            undeliverednotes=> 'undelivered_notes',
        );

    foreach my $key ( keys %{ $file_content } ) {
        # if the lowercase version exists in the above
        # hash then store it under our name
        if ( exists( $to_get{ lc( $key ) } ) ) {

            my $our_name    = $to_get{ lc( $key ) };
            my $value       = $file_content->{ $key };

            # check if the 'value' is an empty hash if
            # it is then that means the field was empty
            if ( ref( $value ) eq 'HASH' && !keys %{ $value } ) {
                $value  = undef;
            }

            $content->{ $our_name } = $value;
        }
    }

    return $content;
}

=head2 process_content

    $dbic_record    = process_content( $content );
        or
    $dbic_record    = process_content( $content, $logger );

This processes the output from '$self->parse_file_content' and creates
a Routing Schedule record.

=cut

sub process_content {
    my ( $self, $content, $logger ) = @_;

    my $schema  = $self->schema;

    # set-up logger if not passed in
    $logger //= xt_logger( '' );

    my $base_rec;
    my $link_table;
    my $create_args;

    # first check if there is a 'nap_ref' value, otherwise no point continuing
    my $ref     = $content->{nap_ref};
    if ( !$ref ) {
        die "Empty 'nap_ref' can't continue";
    }

    # get the pattern that determins what a valid Order Number is
    my $order_nr_pattern = order_nr_regex();

    # decide whether it's for an RMA or an Order
    if ( $ref =~ m/^${order_nr_pattern}$/ ) {
        # assume Order and then use the Shipment Id field
        $link_table = 'link_routing_schedule__shipments';

        my $shipment_id = $content->{shipment_id};
        $base_rec       = $schema->resultset('Public::Shipment')->find( $shipment_id );
        if ( !defined $base_rec ) {
            die "Couldn't find Shipment Record for Id: '" . ( defined $shipment_id ? $shipment_id : '' ) . "'";
        }

        # check the Shipment is for the correct Order
        my $order   = $base_rec->order;
        if ( !$order || $order->order_nr ne $ref ) {
            die "Shipment '${shipment_id}' is not for Order '${ref}'";
        }

        # set the type now we know it
        $create_args->{routing_schedule_type_id}    = $ROUTING_SCHEDULE_TYPE__DELIVERY;
    }
    else {
        # assume RMA
        $link_table = 'link_routing_schedule__returns';
        $base_rec   = $schema->resultset('Public::Return')->search( { rma_number => $ref } )->first;
        if ( !defined $base_rec ) {
            die "Couldn't find Return Record for RMA: '".$ref."'";
        }

        # set the type now we know it
        $create_args->{routing_schedule_type_id}    = $ROUTING_SCHEDULE_TYPE__COLLECTION;
    }

    if ( $content->{sig_date} ) {
        my ( $day, $month, $year )  = $self->_parse_date( $content->{sig_date} );

        if ( !$day ) {
            die "Can't parse the Signature Date: " . $content->{sig_date};
        }

        my $sig_date    = DateTime->new( time_zone => 'local', day => $day, month => $month, year => $year );

        # if there is a time as well then add that to the date
        if ( $content->{sig_time} ) {
            eval {
                my ( $hour, $minute, $second )  = split( qr{:}, $content->{sig_time} );
                $sig_date->set( hour => $hour, minute => $minute, second => $second // 0 );
            };
            if ( my $err = $@ ) {
                $logger->warn(
                     "External Id: '" . $content->{external_id} . "', NAP Ref: '${ref}'" .
                     ", Invalid 'SIGTime' passed in :'" . ( $content->{sig_time} // '' ) . "'" .
                     ", Error: ${err}"
                );
            }
        }

        # make sure it gets stored on the record
        $create_args->{signature_time}  = $sig_date;
    }

    if ( $content->{delivery_window_date} ) {
        my ( $day, $month, $year )  = $self->_parse_date( $content->{delivery_window_date} );

        if ( !$day ) {
            die "Can't parse the Delivery Window Date: " . $content->{delivery_window_date};
        }

        my $win_date    = DateTime->new( day => $day, month => $month, year => $year );

        # make sure it gets stored on the record
        $create_args->{task_window_date}    = $win_date;
    }

    # find the Status Rec for the Status found in the file
    $content->{status}  ||= 'Scheduled';
    my $status  = $schema->resultset('Public::RoutingScheduleStatus')
                                        ->search( { name => { ILIKE => $content->{status} } } )
                                            ->first;
    if ( !$status ) {
        die "Couldn't find a Status for: '$$content{status}'";
    }

    # the length of the fields in the table
    my $rout_sched_rs   = $schema->resultset('Public::RoutingSchedule');
    my $signatory_size  = $rout_sched_rs->result_source->column_info( 'signatory' )->{size};
    my $notes_size      = $rout_sched_rs->result_source->column_info( 'undelivered_notes' )->{size};

    $create_args    = {
            %{ $create_args },
            routing_schedule_status_id  => $status->id,
            external_id                 => $content->{external_id},
            task_window                 => $content->{delivery_window},
            driver                      => $content->{driver},
            run_number                  => $content->{run_number},
            run_order_number            => $content->{run_order_number},
            signatory                   => ( $content->{signatory} ? substr($content->{signatory}, 0, $signatory_size ) : $content->{signatory} ),
            undelivered_notes           => ( $content->{undelivered_notes} ? substr($content->{undelivered_notes}, 0, $notes_size ) : $content->{undelivered_notes} ),
        };

    my $routing_schedule    = $rout_sched_rs->create( $create_args );

    # now link it to it's appropriate record
    $base_rec->create_related( $link_table, { routing_schedule_id => $routing_schedule->id } );

    # put on the 'alerts_to_send' Array for later
    $self->add_to_alerts( {
                        rec_class   => ref( $base_rec ),
                        id          => $base_rec->id,
                    } );

    return $routing_schedule->discard_changes;
}

=head2 send_alerts

    $count  = $schedule->send_alerts( [ $logger ] );

Sends out the Alerts for all of the Shipment/Return Records that have been processed by 'process_content' and pushed onto
the ArrayRef 'alerts_to_send'. It will call the 'send_routing_schedule_notification' method on the appropriate record
only once for each Return/Shipment even if the record appears more than once in the Array.

Pass an optional $logger of 'Log4Perl' to log any failures.

Will return the number of calls to send out an Alert, it's up to 'send_routing_schedule_notification' to actually decide
whether to 'send' the Alert or not.

By calling this method after Processing all Schedules, Customers are not bombared with successive Alerts should multiple
Schedule Records for the same Shipment/Return have been processed in the same batch. Most likely and to err on the side of
caution only the last Schedule record will be the important one and so should be the ONLY one that its Alert is sent for.

=cut

sub send_alerts {
    my ( $self, $logger )   = @_;

    my %alerts_sent;
    my $count   = 0;

    my $schema  = $self->schema;

    ALERT:
    while ( my $alert = $self->get_next_alert ) {

        my $sent_key    = $alert->{rec_class}."_".$alert->{id};
        next ALERT      if ( exists( $alerts_sent{ $sent_key } ) );

        eval {
            $schema->txn_do( sub {
                my $rec = $schema->resultset( $alert->{rec_class} )->find( $alert->{id} );
                $rec->send_routing_schedule_notification( $self->msg_factory, $logger );
                $count++;

                # flag that this Return/Shipment has sent all the
                # Alerts it needs to, so no need to do it again
                $alerts_sent{ $sent_key }   = 1;
            } );
        };
        if ( my $err = $@ ) {
            $logger->error( "Sending Alert: " . pp( $alert ) . "\n$err" )       if ( $logger );
        }
    }

    return $count;
}


# used to parse a date either 'DD/MM/YYYY', 'YYYY/MM/DD' or 'YYYY-MM-DD'
sub _parse_date {
    my ( $self, $date ) = @_;

    my ( $day, $month, $year );

    # adjust based on how the date looks to be formed
    if ( $date =~ m[(\d{2})/(\d{2})/(\d{4})] ) {
        # DD/MM/YYYY
        ( $day, $month, $year ) = ( $1, $2, $3 );
    }
    elsif ( $date =~ m[(\d{4})/(\d{2})/(\d{2})] || $date =~ m[(\d{4})-(\d{2})-(\d{2})] ) {
        # YYYY/MM/DD or YYYY-MM-DD
        ( $year, $month, $day ) = ( $1, $2, $3 );
    }
    else {
        return;
    }

    return ( $day, $month, $year );
}


__PACKAGE__->meta->make_immutable;

1;
