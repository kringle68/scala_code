package XTracker::Schema::ResultSet::Public::Operator;
# vim: ts=4 sts=4 et sw=4 sr sta
use strict;
use warnings;

use base 'DBIx::Class::ResultSet';

use XTracker::Constants::FromDB qw( :reservation_status :flag );
use XTracker::Config::Local     qw( order_search_by_designer_result_file_path );
use XTracker::Logfile           qw( xt_logger );

use IO::File;
use Text::CSV;

use Carp;


sub get_operator {

    my ( $resultset, $operator_id ) = @_;

    my $operator = $resultset->find(
        { 'me.id' => $operator_id, },
        { prefetch => 'department' },
    );

    return $operator;

}

sub operator_list {
    my ($resultset,$cond,$rows,$offset) = @_;

    my @list    = $resultset->search ( $cond,
        {
            order_by => 'name ASC',
            rows => $rows,
            offset => $offset,
            prefetch => 'department'
        }
    );

    return \@list;
}

sub get_operator_by_username {

    my ( $resultset, $operator_username ) = @_;

    my $operator = $resultset->find(
        { 'me.username' => $operator_username, },
        { prefetch => 'department' },
    );

    return $operator;

}

sub by_authorisation {
    my ( $self, $section_name, $sub_section_name ) = @_;

    my $sub_section = $self->result_source->schema->resultset('Public::AuthorisationSubSection')->find(
        { sub_section => $sub_section_name, 'section.section' => $section_name },
        { 'join' => 'section' },
    );

    if ( defined $sub_section ) {

        my $operators = $self->search(
            { 'permissions.authorisation_sub_section_id' => $sub_section->id },
            { 'join' => 'permissions' },
        );

        return $operators;

    }

}

=head2 in_department

    $schema->resultset('Public::Operator')->in_department( [
        $DEPARTMENT__PERSONAL_SHOPPING,
        $DEPARTMENT__FASHION_ADVISOR
    ] );

Returns an RS of operators in the specified departments. The departments
are specified by passing an array ref containing a list of the required
departments.

=cut

sub in_department {
    my ($self, $departments) = @_;

    die "You must pass a list of departments as an array ref" unless
        defined $departments and ref $departments eq 'ARRAY';

    return $self->search( {
        disabled        => { '!=' => 1 },
        department_id   => { 'IN' => $departments },
    },
    {
        order_by => 'name ASC',
    } );
}

=head2 with_live_reservation

Returns an RS containing operators who have a live reservation.

=cut

sub with_live_reservation {
    my $self = shift;

    return $self->search( {
        'reservations.status_id' => $RESERVATION_STATUS__UPLOADED,
    },
    {
        join => 'reservations'
    } );
}

=head2 operators_in_departments_for_ui

    Gets list of operators for given departments. It builds an array of hash with
    operator id and name as keys to help build a dropdown for UI

=cut

sub operators_in_departments_for_ui {
    my ($self, $departments) = @_;

    die "List of departments cannot be empty" unless $departments;

    my $depts = ( ref $departments eq 'ARRAY' ) ? $departments : [ $departments ] ;

    my @operators =  $self->in_department( $depts) ;
    my @all_operators;

    foreach my $op ( @operators ) {
        push (@all_operators, {
            id   => $op->id,
            name => $op->name
        });
    }

    return \@all_operators;

}

=head2 parse_orders_search_by_designer_file_name

    $hash_ref = $self->parse_orders_search_by_designer_file_name( $file_name );

Given a filename that was generated by 'Public::Operator->create_orders_search_by_designer_file_name'
this will parse it and return the relevant bits including the Operator & Designer.

File-names that it expects are in the format:
    OPID_DESID_CHID_YYYYMMDDHHMMSS_STATE_NUMRECS.txt

    such as:
    1234_54332_1_20151227134508_PENDING.txt
                or
    # using CHID of ZERO if the search wasn't Channelised
    1234_54332_0_20151227134508_COMPLETED_1234.txt

and will return the following structure:

    {
        operator => $operator_rec,
        designer => $designer_rec,
        state    => 'PENDING', 'SEARCHING' or 'COMPLETED',
        datetime => $datetime_obj,
        # if state is 'COMPLETED':
        number_of_records => 123,
        # if the search was Channelised
        channel  => $channel_rec,
    }

=cut

sub parse_orders_search_by_designer_file_name {
    my ( $self, $file_name ) = @_;

    # pattern to parse the file-name
    my $pattern = qr/
        (?<operator_id>\d+)_
        (?<designer_id>\d+)_
        (?<channel_id> \d+)_

        # date & time
        (?<year> \d{4})
        (?<month>\d{2})
        (?<day>  \d{2})
        (?<hour> \d{2})
        (?<min>  \d{2})
        (?<sec>  \d{2})_

        (?<state>[a-z]+)
        (?:_(?<records>\d+))?
        \.
    /xi;

    my $retval;
    if ( $file_name =~ m/${pattern}/ ) {
        my $schema = $self->result_source->schema;

        # get the time-zone the DB is in
        my $time_zone = $schema->db_now()->time_zone;

        $retval = {
            state    => lc( $+{state} ),
            operator => $schema->resultset('Public::Operator')->find( $+{operator_id} ),
            designer => $schema->resultset('Public::Designer')->find( $+{designer_id} ),
            number_of_records => $+{records},
            datetime => DateTime->new( {
                year  => $+{year},
                month => $+{month},
                day   => $+{day},
                hour  => $+{hour},
                minute=> $+{min},
                second=> $+{sec},
                time_zone => $time_zone,
            } ),
            # store the file-name for reference
            file_name => $file_name,
            # and if the search was Channelised
            (
                $+{channel_id}
                ? (
                    channel => $schema->resultset('Public::Channel')
                                        ->find( $+{channel_id} )
                )
                : ()
            ),
        };
    }

    return $retval;
}

=head2 get_list_of_search_orders_by_designer_result_files

    $array_ref = $self->get_list_of_search_orders_by_designer_result_files();

Reads the directory that contains all of the Search Result files that will
have been created from the 'Customer Care->Search Orders By Designer' page.

Will return an Array Ref. with each element containing the same as the return
value from the 'parse_orders_search_by_designer_file_name' method.

The elements in the Array will be sorted in Date order, the Date being the
Date & Time that is present in the file-name of the file.

=cut

sub get_list_of_search_orders_by_designer_result_files {
    my $self = shift;

    my $path = order_search_by_designer_result_file_path();

    my $dir_handle;
    opendir( $dir_handle, $path ) || croak "Can't open '${path}': " . $!;
    my @files = readdir( $dir_handle );
    closedir( $dir_handle );

    my @retval;
    foreach my $file ( @files ) {
        if ( my $details = $self->parse_orders_search_by_designer_file_name( $file ) ) {
            push @retval, $details;
        }
    }

    return \@retval;
}

=head2 get_list_of_search_orders_by_designer_result_files_for_view

    $array_ref = $self->get_list_of_search_orders_by_designer_result_files_for_view();

Calls '$self->get_list_of_search_orders_by_designer_result_files' but then sorts the
results in Date Order (and then by Operator Name) and and formats the Date so that
it can be shown on a Page to the Operators.

=cut

sub get_list_of_search_orders_by_designer_result_files_for_view {
    my $self = shift;

    my %state_description = (
        pending   => 'Pending',
        searching => 'Searching',
        completed => 'Completed',
    );

    my $list = $self->get_list_of_search_orders_by_designer_result_files();

    my @out = (
        map {
            {
                %{ $_ },
                state_description => $state_description{ $_->{state} },
                date_string       => $_->{datetime}->format_cldr( "yyyy-MM-dd '\@' HH:mm" ),
            }
        } sort {
            # sort by Date Order primarily and if they're
            # the same sort by the Operator's Name
            $b->{datetime}->compare( $a->{datetime} )
                || $a->{operator}->name cmp $b->{operator}->name
        } @{ $list }
    );

    return \@out;
}

=head2 read_search_orders_by_designer_result_file

    $array_ref = $self->read_search_orders_by_designer_result_file( $file_name );

As part of the 'Customer Care->Search Orders By Designer' functionality, given a file name
this will read it and return the contents in an Array Ref. of Hash Refs using the first Row
of the file as the Column headings.

=cut

sub read_search_orders_by_designer_result_file {
    my ( $self, $file_name ) = @_;

    return      if ( !$file_name );

    my $path           = order_search_by_designer_result_file_path();
    my $full_file_name = "${path}/${file_name}";

    if ( ! -s "${full_file_name}" ) {
        # can't find file (or is ZERO bytes)
        xt_logger->info( "File: '${full_file_name}' doesn't exist or is ZERO bytes in size" );
        return;
    }

    my $csv = Text::CSV->new( {
        binary => 1,
        eol    => "\n",
        always_quote => 1,
    } );

    my $fh = IO::File->new( $full_file_name, "<:encoding(utf8)" )
                    or croak "Couldn't open file: '${full_file_name}' in 'read_search_orders_by_designer_result_file'";

    # first row has the column headings
    my $headings = $csv->getline( $fh );
    $csv->column_names( @{ $headings } );

    my @rows;
    while ( my $row = $csv->getline_hr( $fh ) ) {
        push @rows, $row;
    }
    $fh->close();

    if ( !$csv->eof() ) {
        xt_logger->log_croak( "Error whilst reading file '${full_file_name}': " . $csv->error_diag() );
    }

    return \@rows;
}

=head2 process_search_orders_by_designer_result_file_contents

    $array_ref = $self->process_search_orders_by_designer_result_file_contents( $contents_of_file );
            or
    $array_ref = $self->process_search_orders_by_designer_result_file_contents(
        $contents_of_file,
        {   # use these for pagination
            page           => 1,
            number_of_rows => 10,
        }
    );

As part of the 'Customer Care->Search Orders By Designer' functionality this will take the contents that
the method 'read_search_orders_by_designer_result_file' gets and then return the Results with all of
the Order and Customer information added to it. It will use the Shipment Id as the basis of finding
out all of the other information.

By default it will return the Order & Customer information for all of the Contents but in order to
not stress the Database then this method should be used to return data in pages by passing in the
'page' and 'number_of_rows' arguments which specifies which page to get based on the number of
rows that should be in each page.

=cut

sub process_search_orders_by_designer_result_file_contents {
    my ( $self, $contents, $args  ) = @_;

    # return an Empty Array Ref. if given no Contents
    return []   if ( !$contents );

    my $schema = $self->result_source->schema;

    my $page            = $args->{page}           // 1;
    my $num_rows_to_get = $args->{number_of_rows} // scalar( @{ $contents } );

    my $max_array_idx   = $#{ $contents };

    # workout the start & end array indexes based
    # on the pagination arguments passed in
    my $start = ( $page - 1 ) * $num_rows_to_get;
    $start    = ( $start < 0 ? 0 : $start );
    my $end   = $start + ( $num_rows_to_get - 1 );
    $end      = ( $end > $max_array_idx ? $max_array_idx : $end );

    if ( $start > $max_array_idx ) {
        # asked for a page that doesn't exist return empty array
        return [];
    }

    # just get the Shipment Ids for the page requested
    my @shipment_ids = map { $_->{shipment_id} } @{ $contents }[ $start..$end ];

    # now get the Order & Customer information for the Shipment
    my $rs = $schema->resultset('Public::Orders')->get_search_results_by_shipment_id_rs(
        \@shipment_ids,
    );

    # need to get the results in the same sequence as the Shipment
    # Ids so put all the records keyed by Shipment Id into a Hash
    # so that they can be pulled out directly when later looping
    # over the Shipment Ids
    my %recs = map {
        $_->get_column('shipment_id') => $_
    } $rs->all;

    my @retval;
    SHIP_ID:
    foreach my $ship_id ( @shipment_ids ) {
        next SHIP_ID        if ( !exists( $recs{ $ship_id } ) );
        push @retval, $recs{ $ship_id };
    }

    return \@retval;
}

=head2 process_search_orders_by_designer_result_file_contents_for_json

    $array_ref = $self->process_search_orders_by_designer_result_file_contents_for_json(
        # takes the same parameters as the method:
        #       $self->process_search_orders_by_designer_result_file_contents
    );

This does the same thing as the method 'process_search_orders_by_designer_result_file_contents' but
gets the results suitable to be turned into a JSON string by not having any blessed data in the
resulting data structure.

=cut

sub process_search_orders_by_designer_result_file_contents_for_json {
    my $self = shift;

    # just pass the arguments straight on to the other method
    my $results = $self->process_search_orders_by_designer_result_file_contents( @_ );

    # go round each row and get the raw columns from the DBIC object
    my @retval;
    foreach my $row ( @{ $results } ) {
        my %fields = $row->get_columns();

        # make some readable Order date & time fields
        $fields{order_date} = $row->date->ymd('-');
        $fields{order_time} = $row->date->hms(':');
        # just have the time upto minutes
        $fields{order_time_mins} = $row->date->format_cldr("HH:mm");

        push @retval, \%fields;
    }

    return \@retval;
}


1;
